// Copyright 2025 HP Development Company, L.P.
// SPDX-License-Identifier: MIT

package rest

import (
	"encoding/json"
	"fmt"
	"net/http"
	"strings"
	"time"

	"github.com/HPInc/krypton-es/es/service/db"
	"github.com/HPInc/krypton-es/es/service/notification"
	"github.com/HPInc/krypton-es/es/service/structs"
	"github.com/google/uuid"
	"go.uber.org/zap"
)

type enrollResponse struct {
	ID        uuid.UUID `json:"id"`
	RequestId string    `json:"request_id"`
	Elapsed   string    `json:"elapsed"`
}

/*
Enroll call consists of two parts. One is the access token generated by azure sts.
1. access token generated by azure sts (from authorization header)
2. certificate signing request from device (base64 encoded string)
This function will do the following
1. Verify the access token
2. Creates db entry to track incoming request
3. Push CSR and db entry id to SQS
Requires:
- Custom header: X-HP-Token-Type
  - Value: "azuread" or "enrollment"
  - Authorization header: Bearer <Token>
  - Payload:
    {
    "csr":"<base64 encoded certificate signing request>"
    "hardware_hash":"<device hardware hash>"
    }

Returns:
- 202 (request is accepted and will eventually be processed)
  - id of pending enroll. This id can be used to follow up.

Errors:
- 400
  - Malformed or missing Authorization header
  - Malformed or missing payload

- 401
  - Could not verify token
  - Token expired or not yet valid
  - Audience or subject has invalid values (note: these are configurable in es)

- 405
  - Must be POST

- 500
  - should not be here. yet, here we are.
*/
func Enroll(w http.ResponseWriter, r *http.Request) *enrollError {
	startTime := time.Now()

	ei, err := GetEnrollInfoFromToken(r)
	if err != nil {
		if IsTokenTypeHeaderError(err) {
			return &enrollError{err, http.StatusBadRequest}
		}
		return &enrollError{err, http.StatusUnauthorized}
	}

	payload, err := GetEnrollPayload(r)
	if err != nil {
		return &enrollError{err, http.StatusBadRequest}
	}

	// check if management server is in config
	if err = payload.ValidateManagementService(); err != nil {
		return &enrollError{err, http.StatusBadRequest}
	}

	// check if enroll request is already in db
	hasCSRHash, err := db.HasCSRHash(payload.CSRHash)
	if err != nil {
		return &enrollError{ErrLookupCsr, getHttpCodeForDbError(err)}
	}
	// if enroll request was previously seen, return conflict
	if hasCSRHash {
		return &enrollError{ErrDuplicateCsr, http.StatusConflict}
	}

	de, err := db.CreateEnrollRecord(ei.TenantId, ei.UserId, payload.CSRHash)
	if err != nil {
		return &enrollError{ErrCreateEnroll, getHttpCodeForDbError(err)}
	}
	payload.ID = de.Id
	payload.RequestId = de.RequestId
	payload.TenantId = ei.TenantId

	if err = pushToPendingEnrollQueue(payload); err != nil {
		return &enrollError{ErrHandoffEnroll, http.StatusInternalServerError}
	}

	sendEnrollResponse(w, de, startTime)
	esLogger.Info(
		"Enroll queued",
		zap.String("ID", payload.ID.String()),
		zap.String("RequestID", de.RequestId),
		zap.String("TenantID", ei.TenantId),
		zap.String("Elapsed", time.Since(startTime).String()))
	return nil
}

func pushToPendingEnrollQueue(ep *enrollPayload) error {
	jsonstring, err := json.Marshal(*ep)
	if err != nil {
		return err
	}

	_, err = notification.SendMessage(string(jsonstring))
	if err != nil {
		return err
	}
	return nil
}

func sendEnrollResponse(w http.ResponseWriter, de *structs.DeviceEntry, st time.Time) *enrollError {
	er := enrollResponse{ID: de.Id, RequestId: de.RequestId}
	er.Elapsed = fmt.Sprintf("%v", time.Since(st))
	jsonstring, err := json.Marshal(er)
	if err != nil {
		return &enrollError{ErrInternal, http.StatusInternalServerError}
	}
	w.WriteHeader(http.StatusAccepted)
	fmt.Fprintf(w, "%s", string(jsonstring))
	return nil
}

func IsTokenTypeHeaderError(e error) bool {
	return strings.Contains(e.Error(), headerTokenType)
}
