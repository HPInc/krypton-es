// Copyright 2025 HP Development Company, L.P.
// SPDX-License-Identifier: MIT

package rest

import (
	"net/http"
	"time"

	"github.com/HPInc/krypton-es/es/service/db"
	"github.com/HPInc/krypton-es/es/service/tokenmgr"
	"go.uber.org/zap"
)

const (
	ENROLL_STATUS_ERROR    = -1
	ENROLL_STATUS_PENDING  = 0
	ENROLL_STATUS_ENROLLED = 1
)

/*
Re-Enroll call. Requires the following input
1. access token generated by azure sts (from authorization header)
2. existing tenant_id and device id as path params
3. certificate signing request from device (base64 encoded string)
This function will do the following
1. Verify the access token for a dsts token
3. Push CSR and db entry id to SQS with renew flag
Requires:
- Custom header: X-HP-Token-Type
  - Value: "enrollment"
  - Authorization header: Bearer <Token>
  - Payload:
    {
    "csr":"<base64 encoded part of csr without pem headers>"
    }

Returns:
- 202 (request is accepted and will eventually be processed)
  - id of pending enroll. This id can be used to follow up.

Errors:
- 400
  - Malformed or missing Authorization header
  - Malformed or missing payload

- 401
  - Could not verify token
  - Token expired or not yet valid
  - Audience or subject has invalid values (note: these are configurable in es)

- 405
  - Must be PATCH

- 500
  - should not be here. yet, here we are.
*/
func RenewEnroll(w http.ResponseWriter, r *http.Request) *enrollError {
	startTime := time.Now()

	if err := validateDeviceToken(r); err != nil {
		return &enrollError{err, http.StatusBadRequest}
	}

	ei, err := GetEnrollInfoFromToken(r)
	if err != nil {
		if IsTokenTypeHeaderError(err) {
			return &enrollError{err, http.StatusBadRequest}
		}
		return &enrollError{err, http.StatusUnauthorized}
	}

	payload, err := GetRenewEnrollPayload(r)
	if err != nil {
		return &enrollError{err, http.StatusBadRequest}
	}
	deviceId, enroll_err := getUUIDParam(r, paramDeviceID)
	if enroll_err != nil {
		return enroll_err
	}
	// if the deviceid requested does not match device id in token,
	// return bad request (400)
	if ei.DeviceId != deviceId.String() {
		esLogger.Error(
			"Renew enroll device id mismatch",
			zap.String("request_device_id", deviceId.String()),
			zap.String("token_device_id", ei.DeviceId))
		return &enrollError{ErrDeviceIdMismatch, http.StatusBadRequest}
	}
	payload.TenantId = ei.TenantId
	payload.DeviceId = deviceId

	de, err := db.RenewEnroll(
		ei.TenantId, payload.DeviceId, ei.UserId, payload.CSRHash)
	if err != nil {
		return &enrollError{ErrRenewEnroll, getHttpCodeForDbError(err)}
	}
	payload.ID = de.Id
	payload.RequestId = de.RequestId
	payload.TenantId = ei.TenantId

	if err = pushToPendingEnrollQueue(payload); err != nil {
		return &enrollError{err, http.StatusInternalServerError}
	}

	sendEnrollResponse(w, de, startTime)
	esLogger.Info(
		"Re-Enroll queued",
		zap.String("ID", payload.ID.String()),
		zap.String("RequestID", de.RequestId),
		zap.String("TenantID", ei.TenantId),
		zap.String("DeviceID", payload.DeviceId.String()),
		zap.String("Elapsed", time.Since(startTime).String()))
	return nil
}

// bearer token should be a device token obtained from dsts
func validateDeviceToken(r *http.Request) error {
	// Retrieve the token type specified in the request.
	tokenType := r.Header.Get(headerTokenType)
	if tokenType == "" {
		esLogger.Error(ErrTokenTypeHeaderNotFound.Error())
		return ErrTokenTypeHeaderNotFound
	}

	if tokenmgr.TokenType(tokenType) != tokenmgr.TokenTypeDevice {
		return ErrDeviceTokenNotProvided
	}
	return nil
}
